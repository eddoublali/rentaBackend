import { reservationSchema, reservationUpdateSchema } from './../schema/reservationValidation';
import { Request, Response } from 'express';
import { prismaClient } from '../app';
import { z } from 'zod';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';

/**
 * @desc Create a new Reservation
 * @route POST /api/reservations
 * @method POST
 * @access protected
 */
export const createReservation = async (req: Request, res: Response): Promise<void> => {
  try {
    // Validate the request body using the reservationSchema
    const validatedReservation = reservationSchema.parse(req.body);

    // Check if the vehicle exists
    const vehicle = await prismaClient.vehicle.findUnique({
      where: { id: validatedReservation.vehicleId },
    });

    if (!vehicle) {
      res.status(400).json({ message: 'Vehicle not found.' });
      return;
    }

    // Check if the vehicle is available
    if (vehicle.status !== 'AVAILABLE') {
      res.status(400).json({ message: 'Vehicle is not available.' });
      return;
    }

    // Check if the client exists
    const client = await prismaClient.client.findUnique({
      where: { id: validatedReservation.clientId },
    });

    if (!client) {
      res.status(400).json({ message: 'Client not found.' });
      return;
    }

    // Check if the second driver client exists (if provided)
    if (validatedReservation.secondDriver && validatedReservation.clientSeconId) {
      const secondClient = await prismaClient.client.findUnique({
        where: { id: validatedReservation.clientSeconId },
      });
      if (!secondClient) {
        res.status(400).json({ message: 'Second driver client not found.' });
        return;
      }
      if (validatedReservation.clientSeconId === validatedReservation.clientId) {
        res.status(400).json({ message: 'Second driver cannot be the same as primary client.' });
        return;
      }
    }

    // Check if the vehicle is already reserved during the requested period
    const existingReservation = await prismaClient.reservation.findFirst({
      where: {
        vehicleId: validatedReservation.vehicleId,
        OR: [
          {
            startDate: { lte: validatedReservation.endDate },
            endDate: { gte: validatedReservation.startDate },
          },
        ],
        status: { in: ['PENDING', 'CONFIRMED'] },
      },
    });

    if (existingReservation) {
      res.status(400).json({
        message: 'The vehicle is already reserved for the requested period.',
      });
      return;
    }

    // Create the reservation and update vehicle status in a transaction
    const [newReservation] = await prismaClient.$transaction([
      prismaClient.reservation.create({
        data: {
          ...validatedReservation,
          startDate: new Date(validatedReservation.startDate),
          endDate: new Date(validatedReservation.endDate),
        },
      }),
      prismaClient.vehicle.update({
        where: { id: validatedReservation.vehicleId },
        data: { status: 'RENTED' },
      }),
    ]);

    // Automatically create a revenue entry if payment is complete and reservation is completed
    if (newReservation.paymentStatus === 'PAID' && newReservation.status === 'COMPLETED') {
      await prismaClient.revenue.create({
        data: {
          title: `Revenue from Reservation ${newReservation.id}`,
          amount: newReservation.totalAmount,
          source: 'Reservation',
          date: new Date(),
          notes: 'Revenue generated by completed reservation',
          client: { connect: { id: validatedReservation.clientId } },
          reservation: { connect: { id: newReservation.id } },
          vehicle: { connect: { id: validatedReservation.vehicleId } },
        },
      });
    }

    res.status(201).json({
      message: 'Reservation created successfully',
      reservation: newReservation,
    });
  } catch (error: unknown) {
    console.error('Create reservation error:', error);
    if (error instanceof z.ZodError) {
      res.status(400).json({
        message: 'Validation failed',
        errors: error.errors.map((err) => ({
          field: err.path[0],
          message: err.message,
        })),
      });
      return;
    }

    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2003') {
      res.status(400).json({ message: 'Foreign key constraint failed' });
      return;
    }

    res.status(500).json({
      message: 'Something went wrong',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};

/**
 * @desc Update a Reservation
 * @route PUT /api/reservations/:id
 * @method PUT
 * @access protected
 */
export const updateReservation = async (req: Request, res: Response): Promise<void> => {
  const id = Number(req.params.id);

  if (isNaN(id)) {
    res.status(400).json({ message: 'Invalid reservation ID' });
    return;
  }

  try {
    const validatedData = reservationUpdateSchema.parse(req.body);

    // Check if reservation exists
    const existingReservation = await prismaClient.reservation.findUnique({
      where: { id },
    });

    if (!existingReservation) {
      res.status(404).json({ message: 'Reservation not found.' });
      return;
    }

    // Check if vehicle exists (if vehicleId is provided)
    if (validatedData.vehicleId && validatedData.vehicleId !== existingReservation.vehicleId) {
      const vehicle = await prismaClient.vehicle.findUnique({
        where: { id: validatedData.vehicleId },
      });
      if (!vehicle) {
        res.status(400).json({ message: 'Vehicle not found.' });
        return;
      }
      if (vehicle.status !== 'AVAILABLE') {
        res.status(400).json({ message: 'Vehicle is not available.' });
        return;
      }
    }

    // Check if client exists (if clientId is provided)
    if (validatedData.clientId) {
      const client = await prismaClient.client.findUnique({
        where: { id: validatedData.clientId },
      });
      if (!client) {
        res.status(400).json({ message: 'Client not found.' });
        return;
      }
    }

    // Check if second driver client exists (if provided)
    if (validatedData.secondDriver && validatedData.clientSeconId) {
      const secondClient = await prismaClient.client.findUnique({
        where: { id: validatedData.clientSeconId },
      });
      if (!secondClient) {
        res.status(400).json({ message: 'Second driver client not found.' });
        return;
      }
      if (validatedData.clientSeconId === validatedData.clientId) {
        res.status(400).json({ message: 'Second driver cannot be the same as primary client.' });
        return;
      }
    }

    // Check for reservation conflicts (if dates or vehicleId are updated)
    if (
      validatedData.startDate ||
      validatedData.endDate ||
      validatedData.vehicleId
    ) {
      const conflict = await prismaClient.reservation.findFirst({
        where: {
          id: { not: id },
          vehicleId: validatedData.vehicleId || existingReservation.vehicleId,
          OR: [
            {
              startDate: {
                lte: validatedData.endDate || existingReservation.endDate,
              },
              endDate: {
                gte: validatedData.startDate || existingReservation.startDate,
              },
            },
          ],
          status: { in: ['PENDING', 'CONFIRMED'] },
        },
      });

      if (conflict) {
        res.status(400).json({
          message: 'The vehicle is already reserved for the requested period.',
        });
        return;
      }
    }

    // Update reservation and vehicle status in a transaction
    const [updatedReservation] = await prismaClient.$transaction([
      prismaClient.reservation.update({
        where: { id },
        data: {
          ...validatedData,
          startDate: validatedData.startDate ? new Date(validatedData.startDate) : undefined,
          endDate: validatedData.endDate ? new Date(validatedData.endDate) : undefined,
        },
      }),
      // Update vehicle status if necessary
      prismaClient.$queryRaw`SELECT 1`, // Placeholder to maintain transaction
    ]);

    // Handle vehicle status
    const vehicleId = validatedData.vehicleId || existingReservation.vehicleId;
    if (updatedReservation.status === 'CANCELED' || updatedReservation.status === 'COMPLETED') {
      const activeReservations = await prismaClient.reservation.findMany({
        where: {
          vehicleId,
          id: { not: id },
          status: { in: ['PENDING', 'CONFIRMED'] },
        },
      });

      if (activeReservations.length === 0) {
        await prismaClient.vehicle.update({
          where: { id: vehicleId },
          data: { status: 'AVAILABLE' },
        });
      }
    } else if (updatedReservation.status === 'PENDING' || updatedReservation.status === 'CONFIRMED') {
      await prismaClient.vehicle.update({
        where: { id: vehicleId },
        data: { status: 'RENTED' },
      });
    }

    // Handle revenue entry
    const existingRevenue = await prismaClient.revenue.findFirst({
      where: { reservationId: updatedReservation.id },
    });

    if (
      !existingRevenue &&
      updatedReservation.paymentStatus === 'PAID' &&
      updatedReservation.status === 'COMPLETED'
    ) {
      await prismaClient.revenue.create({
        data: {
          title: `Revenue from Reservation ${updatedReservation.id}`,
          amount: updatedReservation.totalAmount,
          source: 'Reservation',
          date: new Date(),
          notes: 'Revenue generated by completed reservation',
          client: { connect: { id: updatedReservation.clientId } },
          reservation: { connect: { id: updatedReservation.id } },
          vehicle: { connect: { id: updatedReservation.vehicleId } },
        },
      });
    } else if (
      existingRevenue &&
      updatedReservation.paymentStatus === 'PAID' &&
      updatedReservation.status === 'COMPLETED'
    ) {
      await prismaClient.revenue.update({
        where: { id: existingRevenue.id },
        data: {
          amount: updatedReservation.totalAmount,
          date: new Date(),
        },
      });
    } else if (
      existingRevenue &&
      (updatedReservation.paymentStatus !== 'PAID' || updatedReservation.status !== 'COMPLETED')
    ) {
      await prismaClient.revenue.delete({
        where: { id: existingRevenue.id },
      });
    }

    res.status(200).json({
      message: 'Reservation updated successfully',
      reservation: updatedReservation,
    });
  } catch (error: unknown) {
    console.error('Update reservation error:', error);
    if (error instanceof z.ZodError) {
      res.status(400).json({
        message: 'Validation failed',
        errors: error.errors.map((err) => ({
          field: err.path[0],
          message: err.message,
        })),
      });
      return;
    }

    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2003') {
      res.status(400).json({ message: 'Foreign key constraint failed' });
      return;
    }

    res.status(500).json({
      message: 'Something went wrong',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};

/**
 * @desc Get all Reservations
 * @route GET /api/reservations
 * @method GET
 * @access protected
 */
export const getAllReservations = async (req: Request, res: Response): Promise<void> => {
  try {
    const reservations = await prismaClient.reservation.findMany({
      include: {
        vehicle: true,
        client: true,
        secondClient: true,
        invoices: true,
      },
    });

    res.status(200).json({
      message: 'Reservations fetched successfully',
      reservations,
    });
  } catch (error) {
    console.error('Get all reservations error:', error);
    res.status(500).json({
      message: 'Failed to fetch reservations',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};

/**
 * @desc Get a single Reservation
 * @route GET /api/reservations/:id
 * @method GET
 * @access protected
 */
export const getOneReservation = async (req: Request, res: Response): Promise<void> => {
  const id = Number(req.params.id);

  if (isNaN(id)) {
    res.status(400).json({ message: 'Invalid reservation ID' });
    return;
  }

  try {
    const reservation = await prismaClient.reservation.findUnique({
      where: { id },
      include: {
        vehicle: true,
        client: true,
        secondClient: true,
        invoices: true,
      },
    });

    if (!reservation) {
      res.status(404).json({ message: 'Reservation not found' });
      return;
    }

    res.status(200).json({
      message: 'Reservation fetched successfully',
      reservation,
    });
  } catch (error) {
    console.error('Get one reservation error:', error);
    res.status(500).json({
      message: 'Failed to fetch reservation',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};

/**
 * @desc Delete a Reservation
 * @route DELETE /api/reservations/:id
 * @method DELETE
 * @access protected
 */
export const deleteReservation = async (req: Request, res: Response): Promise<void> => {
  const id = Number(req.params.id);

  if (isNaN(id)) {
    res.status(400).json({ message: 'Invalid reservation ID' });
    return;
  }

  try {
    const existing = await prismaClient.reservation.findUnique({ where: { id } });

    if (!existing) {
      res.status(404).json({ message: 'Reservation not found' });
      return;
    }

    // Delete reservation and update vehicle status in a transaction
    await prismaClient.$transaction([
      prismaClient.reservation.delete({
        where: { id },
      }),
      // Check for other active reservations
      prismaClient.$queryRaw`SELECT 1`, // Placeholder
    ]);

    // Update vehicle status
    const activeReservations = await prismaClient.reservation.findMany({
      where: {
        vehicleId: existing.vehicleId,
        status: { in: ['PENDING', 'CONFIRMED'] },
      },
    });

    if (activeReservations.length === 0) {
      await prismaClient.vehicle.update({
        where: { id: existing.vehicleId },
        data: { status: 'AVAILABLE' },
      });
    }

    res.status(200).json({ message: 'Reservation deleted successfully' });
  } catch (error) {
    console.error('Delete reservation error:', error);
    res.status(500).json({
      message: 'Failed to delete reservation',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};

/**
 * @desc Delete all Reservations
 * @route DELETE /api/reservations
 * @method DELETE
 * @access protected
 */
export const deleteAllReservations = async (req: Request, res: Response): Promise<void> => {
  try {
    await prismaClient.reservation.deleteMany();

    // Optionally reset vehicle statuses
    await prismaClient.vehicle.updateMany({
      data: { status: 'AVAILABLE' },
    });

    res.status(200).json({
      message: 'All reservations deleted successfully',
    });
  } catch (error) {
    console.error('Delete all reservations error:', error);
    res.status(500).json({
      message: 'Failed to delete all reservations',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};