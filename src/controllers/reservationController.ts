import { reservationSchema, reservationUpdateSchema } from './../schema/reservationValidation'; // Adjust path if necessary
import { Request, Response } from 'express';
import { prismaClient } from '../app';
import { z } from 'zod';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';

/**
 * @desc Create a new Reservation
 * @route POST /api/reservation
 * @method POST
 * @access protected
 */
export const createReservation = async (req: Request, res: Response): Promise<void> => {
  try {
    // Validate the request body using the reservationSchema
    const validatedReservation = reservationSchema.parse(req.body);

    // Check if the vehicle exists
    const vehicle = await prismaClient.vehicle.findUnique({
      where: { id: validatedReservation.vehicleId },
    });

    if (!vehicle) {
      res.status(400).json({ message: 'Vehicle not found.' });
      return;
    }

    // Check if the client exists
    const client = await prismaClient.client.findUnique({
      where: { id: validatedReservation.clientId },
    });

    if (!client) {
      res.status(400).json({ message: 'Client not found.' });
      return;
    }

    // Check if the vehicle is already reserved during the requested period
    const existingReservation = await prismaClient.reservation.findFirst({
      where: {
        vehicleId: validatedReservation.vehicleId,
        OR: [
          {
            startDate: { lt: validatedReservation.endDate },
            endDate: { gt: validatedReservation.startDate },
          },
        ],
      },
    });

    if (existingReservation) {
      res.status(400).json({
        message: 'The vehicle is already reserved for the requested period.',
      });
      return;
    }

    // Create the reservation in the database
    const newReservation = await prismaClient.reservation.create({
      data: { ...validatedReservation },
    });

    // Automatically create a revenue entry if payment is complete and reservation is completed
    if (newReservation.paymentStatus === 'PAID' && newReservation.status === 'COMPLETED') {
      await prismaClient.revenue.create({
        data: {
          title: `Revenue from Reservation ${newReservation.id}`,
          amount: newReservation.totalAmount, // Assuming the totalAmount is the revenue
          source: 'Reservation',
          date: new Date(),
          notes: 'Revenue generated by completed reservation',
          client: { connect: { id: validatedReservation.clientId } }, // Connect client
          reservation: { connect: { id: newReservation.id } },      // Connect reservation
          vehicle: { connect: { id: validatedReservation.vehicleId } }, // Connect vehicle
        },
      });
    }

    // Send response with the created reservation data
    res.status(201).json({
      message: 'Reservation created successfully',
      reservation: newReservation,
    });

  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      res.status(400).json({
        message: 'Validation failed',
        errors: error.errors.map((err) => ({
          field: err.path[0],
          message: err.message,
        })),
      });
      return;
    }

    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2003') {
      res.status(400).json({ message: 'Foreign key constraint failed', error });
      return;
    }

    res.status(500).json({ message: 'Something went wrong', error: error instanceof Error ? error.message : 'Unknown error' });
  }
};


/**
 * @desc Update a Reservation
 * @route PUT /api/reservation/:id
 * @method PUT
 * @access protected
 */
export const updateReservation = async (req: Request, res: Response): Promise<void> => {
  const id = req.params.id;
  const userId = Number(id);

  if (isNaN(userId)) {
    res.status(400).json({ message: 'Invalid reservation ID' });
    return;
  }

  try {
    const validatedData = reservationUpdateSchema.parse(req.body);

    // Check if reservation exists
    const existingReservation = await prismaClient.reservation.findUnique({
      where: { id: userId },
    });

    if (!existingReservation) {
      res.status(404).json({ message: 'Reservation not found.' });
      return;
    }

    if (validatedData.vehicleId) {
      const vehicle = await prismaClient.vehicle.findUnique({
        where: { id: validatedData.vehicleId },
      });
      if (!vehicle) {
        res.status(400).json({ message: 'Vehicle not found.' });
        return;
      }
    }

    if (validatedData.clientId) {
      const client = await prismaClient.client.findUnique({
        where: { id: validatedData.clientId },
      });
      if (!client) {
        res.status(400).json({ message: 'Client not found.' });
        return;
      }
    }

    if (validatedData.startDate && validatedData.endDate && validatedData.vehicleId) {
      const conflict = await prismaClient.reservation.findFirst({
        where: {
          id: { not: userId },
          vehicleId: validatedData.vehicleId,
          OR: [
            {
              startDate: { lt: validatedData.endDate },
              endDate: { gt: validatedData.startDate },
            },
          ],
        },
      });

      if (conflict) {
        res.status(400).json({
          message: 'The vehicle is already reserved for the requested period.',
        });
        return;
      }
    }

    // Update reservation
    const updatedReservation = await prismaClient.reservation.update({
      where: { id: userId },
      data: validatedData,
    });

    // Check if a revenue entry already exists for this reservation
    const existingRevenue = await prismaClient.revenue.findUnique({
      where: { id: updatedReservation.id }, // Use the reservation id as the revenue id
    });

    // If no revenue entry exists and the reservation is PAID and COMPLETED, create a new one
    if (!existingRevenue && updatedReservation.paymentStatus === 'PAID' && updatedReservation.status === 'COMPLETED') {
      await prismaClient.revenue.create({
        data: {
          title: `Revenue from Reservation ${updatedReservation.id}`,
          amount: updatedReservation.totalAmount, // Assuming the totalAmount is the revenue
          source: 'Reservation',
          date: new Date(),
          notes: 'Revenue generated by completed reservation',
          client: { connect: { id: validatedData.clientId } },
          reservation: { connect: { id: updatedReservation.id } },
          vehicle: { connect: { id: validatedData.vehicleId } },
        },
      });
    }

    // If revenue entry already exists and the reservation's totalAmount is updated, update the revenue
    if (existingRevenue && updatedReservation.paymentStatus === 'PAID' && updatedReservation.status === 'COMPLETED') {
      await prismaClient.revenue.update({
        where: { id: updatedReservation.id }, // Use the reservation id as the revenue id
        data: {
          amount: updatedReservation.totalAmount, // Update with the new totalAmount
          date: new Date(), // Update the date as well
        },
      });
    }

    // If the reservation is not PAID and not COMPLETED, delete the revenue if it exists
    if (
      existingRevenue &&
      updatedReservation.paymentStatus !== 'PAID' &&
      updatedReservation.status !== 'COMPLETED'
    ) {
      await prismaClient.revenue.delete({
        where: { id: updatedReservation.id }, // Use the reservation id as the revenue id
      });
    }

    res.status(200).json({
      message: 'Reservation updated successfully',
      reservation: updatedReservation,
    });

  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      res.status(400).json({
        message: 'Validation failed',
        errors: error.errors.map((err) => ({
          field: err.path[0],
          message: err.message,
        })),
      });
      return;
    }

    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2003') {
      res.status(400).json({ message: 'Foreign key constraint failed', error });
      return;
    }

    res.status(500).json({ message: 'Something went wrong', error: error instanceof Error ? error.message : 'Unknown error' });
  }
};

export const getAllReservations = async (req: Request, res: Response): Promise<void> => {
    try {
      const reservations = await prismaClient.reservation.findMany({
        include: {
          vehicle: true,
          client: true,
          secondClient: true,
      
          invoices: true,
        },
      });
  
      res.status(200).json({
        message: 'Reservations fetched successfully',
        reservations,
      });
    } catch (error) {
      res.status(500).json({
        message: 'Failed to fetch reservations',
        error,
      });
    }
  };


  export const getOneReservation = async (req: Request, res: Response): Promise<void> => {
    const id = Number(req.params.id);
  
    if (isNaN(id)) {
      res.status(400).json({ message: 'Invalid reservation ID' });
      return;
    }
  
    try {
      const reservation = await prismaClient.reservation.findUnique({
        where: { id },
        include: {
          vehicle: true,
          client: true,
          secondClient: true,
  
          invoices: true,
        },
      });
  
      if (!reservation) {
        res.status(404).json({ message: 'Reservation not found' });
        return;
      }
  
      res.status(200).json({
        message: 'Reservation fetched successfully',
        reservation,
      });
    } catch (error) {
      res.status(500).json({
        message: 'Failed to fetch reservation',
        error,
      });
    }
  };
  export const deleteReservation = async (req: Request, res: Response): Promise<void> => {
    const id = Number(req.params.id);
  
    if (isNaN(id)) {
      res.status(400).json({ message: 'Invalid reservation ID' });
      return;
    }
  
    try {
      const existing = await prismaClient.reservation.findUnique({ where: { id } });
  
      if (!existing) {
        res.status(404).json({ message: 'Reservation not found' });
        return;
      }
  
      await prismaClient.reservation.delete({
        where: { id },
      });
  
      res.status(200).json({ message: 'Reservation deleted successfully' });
    } catch (error) {
      res.status(500).json({
        message: 'Failed to delete reservation',
        error,
      });
    }
  };
  export const deleteAllReservations = async (req: Request, res: Response): Promise<void> => {
    try {
      await prismaClient.reservation.deleteMany();
  
      res.status(200).json({
        message: 'All reservations deleted successfully',
      });
    } catch (error) {
      res.status(500).json({
        message: 'Failed to delete all reservations',
        error,
      });
    }
  };    
